%{
#include <iostream>
using namespace std;
int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
	char *sval;
	double dval;
    /* You may include additional fields as you want. */
    /* char op; */
};

%start query
%expect 14 
%token LPAREN RPAREN DOT COMMA COMP DIRECT OUTER NEG DATE TIME BOOLEAN
%token SELECT DISTINCT ALL STAR FROM AS JOIN JSELECT ON WHERE GROUP BY HAVING UNION MINUS EXCEPT INTERSECT ORDER LIMIT OFFSET NOT EXISTS IS NIL IN ANY SOME ASC DESC NULLS FIRST LAST
%token <dval> DECIMAL
%token <sval> STRING   /* 'val' is the (only) field declared in %union
                       which represents the type of the token. */
%error-verbose

%%

query : select
		;
	
select : 
	| SELECT selectExpression FROM tableExpression others			{ cout << "SELECT * FROM * *" << endl;}
	| SELECT DISTINCT selectExpression FROM tableExpression others	{ cout << "SELECT DISTINCT * FROM * *" << endl;}
	| SELECT ALL selectExpression FROM tableExpression others		{ cout << "SELECT ALL * FROM * *" << endl;}
     ;	
selectExpression : selectExpression COMMA selectExpr
				| selectExpr

selectExpr : expression nameAs 
		| STAR
		;

nameAs : 
	| AS name
	| name
	;

tableExpression : tableExpression COMMA tableExpr
				| tableExpr 
				;

tableExpr : tableName tableNameAs	
		| tableName tableNameAs tableJoin
		;

tableName : LRSelect
		| name
		| name DOT name
		;

LRSelect : LPAREN select RPAREN
		;

tableNameAs : 
			| name
			| AS name
			;

tableJoin : tableJoin join
	| join
	;

join : DIRECT OUTER JOIN tableExpression joinLeft						{ cout << "LEFT/RIGHT OUTER JOIN" << endl;}
	| JSELECT JOIN tableExpression joinLeft								{ cout << "INNER/CROSS NATURAL JOIN" << endl;}
	| DIRECT JOIN tableExpression joinLeft								{ cout << "LEFT/RIGHT JOIN" << endl;}
	| JOIN tableExpression joinLeft										{ cout << "JOIN" << endl;}
	;

joinLeft :
		| ON expression 
		;

others : WHERE expression whereLeft										{ cout << "WHERE" << endl;}
	| whereLeft
	;

whereLeft : GROUP BY expressionSelection groupLeft						{ cout << "GROUP" << endl;}
		| groupLeft
		;

groupLeft : HAVING expression havingLeft								{ cout << "HAVING" << endl;}
		| havingLeft
		;
		
havingLeft : unionSelection LRSelect unionLeft							{ cout << "UNION" << endl;}
		| unionLeft
		;
		
unionSelection : UNION
			| UNION ALL
			| MINUS
			| EXCEPT
			| INTERSECT
			;
		
unionLeft : ORDER BY orderSelection limitLeft							{ cout << "ORDER BY" << endl;}
		| limitLeft
		;
		
orderSelection : orderSelection COMMA order
				| order
				;
				
order : expression ascDesc nullsFL
		;
		
ascDesc : 
		| ASC
		| DESC
		;
		
nullsFL :
		| NULLS FIRST
		| NULLS LAST
		;
				
limitLeft : 
		| LIMIT expression												{ cout << "LIMIT" << endl;}
		| LIMIT expression OFFSET expression							{ cout << "LIMIT OFFSET" << endl;}
		;

expression : condition
			| NOT condition
			| EXISTS LRSelect
			;
			
condition : operand
		| operand conditionRightHandSide
		;
		
conditionRightHandSide : IS NIL									{ cout << "IS NULL" << endl;}
					| IS NOT NIL								{ cout << "IS NOT NULL" << endl;}
					| IN LRSelect								{ cout << "IN" << endl;}
					| IN LPAREN expressionSelection RPAREN		{ cout << "IN ARRAY" << endl;}
					| compare operand							{ cout << "compare" << endl;}
					| compare ALL LRSelect
					| compare ANY LRSelect
					| compare SOME LRSelect
					;
					
operand : NEG DECIMAL											{ cout << "NEG DECIMAL:" << endl;}
		| DECIMAL												{ cout << "POS DECIMAL:" << endl;}
		| name
		| name DOT name
		;

name : STRING													{ cout << "STRING:" << endl;}
	;
	
expressionSelection : expressionSelection COMMA expression
					| expression
					;
					
compare : COMP
		;
		


%%

int main()
{
	yyparse();// A parsing function that will be generated by Bison.
    return 0;
}
